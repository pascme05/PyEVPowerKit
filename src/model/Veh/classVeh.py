#######################################################################################################################
#######################################################################################################################
# Title:        Python Electric Vehicle Power Toolkit (PyEVPowerKit)
# Topic:        EV Modeling
# File:         classVeh
# Date:         18.03.2024
# Author:       Dr. Pascal A. Schirmer
# Version:      V.0.1
# Copyright:    Pascal Schirmer
#######################################################################################################################
#######################################################################################################################

#######################################################################################################################
# Function Description
#######################################################################################################################
"""
A short description of the class goes here.
Inputs:     1)
            2)
            N)
Outputs:    1)
            2)
            M)
"""

#######################################################################################################################
# Import libs
#######################################################################################################################
# ==============================================================================
# Internal
# ==============================================================================

# ==============================================================================
# External
# ==============================================================================
import numpy as np


#######################################################################################################################
# Class
#######################################################################################################################
class classVEH:
    ###################################################################################################################
    # Constructor
    ###################################################################################################################
    def __init__(self, m, c_r, A, c_w, r_rim, m_rim, r_tire, m_tire, r_flat, d_b, d_a, eta, c_Vol, c_rho, c_Cp, c_vis, A_r, A_b):
        self.m = m
        self.c_r = c_r
        self.A = A
        self.c_w = c_w
        self.r_rim = r_rim
        self.m_rim = m_rim
        self.r_tire = r_tire
        self.m_tire = m_tire
        self.r_flat = r_flat
        self.d_b = d_b
        self.d_a = d_a
        self.eta = eta
        self.c_Vol = c_Vol
        self.c_rho = c_rho
        self.c_Cp = c_Cp
        self.c_vis = c_vis
        self.A_r = A_r
        self.A_b = A_b

    ###################################################################################################################
    # Mechanics
    ###################################################################################################################
    def calc_cool(self, dQ_HVS, dQ_INV, dQ_EMA, dQ_GBX, v, Vol, Ta, Tc, dt):
        # ==============================================================================
        # Init
        # ==============================================================================
        # ------------------------------------------
        # Variables
        # ------------------------------------------
        Vol_m = Vol / 60 * self.c_rho

        # ------------------------------------------
        # Parameters
        # ------------------------------------------
        h_r = 40 * (v * 3.6 / 50) + 5
        h_a = 0.0027 * (v * 3.6)**2 + 1.9 * (v * 3.6) + 5

        # ==============================================================================
        # Calculation
        # ==============================================================================
        # ------------------------------------------
        # Heat Balance
        # ------------------------------------------
        dQ = dQ_HVS + dQ_INV + dQ_EMA + dQ_GBX
        dQ_r = h_r * self.A_r * (Ta - Tc) + h_a * self.A_b * (Ta - Tc)
        dQ_net = dQ_r + dQ

        # ------------------------------------------
        # Local Temperature Change
        # ------------------------------------------
        dT = dQ_net / (self.c_Cp * Vol_m) * dt

        # ------------------------------------------
        # Global Temperature Change
        # ------------------------------------------
        Tc = ((Tc + dT) * Vol_m * dt + Tc * (self.c_Vol - Vol_m * dt)) / self.c_Vol

        # ==============================================================================
        # Return
        # ==============================================================================
        return [Tc, dQ_net]

    ###################################################################################################################
    # Forces
    ###################################################################################################################
    def calc_Force(self, v, a, ang, setup):
        # ==============================================================================
        # Init
        # ==============================================================================
        p_a = setup['Par']['p_a']
        v_w = setup['Par']['v_w']
        m_a = setup['Par']['VEH']['m_a']
        g = 9.81

        # ==============================================================================
        # Pre-Processing
        # ==============================================================================
        try:
            state = np.zeros(len(v))
            state[v > 0] = 1
        except:
            if v > 0:
                state = 1
            else:
                state = 0

        # ==============================================================================
        # Calculation
        # ==============================================================================
        Fp = 0.5 * p_a * self.A * self.c_w * (v_w - v) ** 2
        Fr = self.c_r * self.m * g * np.cos(ang) * state
        Fc = self.m * g * np.sin(ang)
        Fa = (self.m + m_a) * a
        Ft = Fp + Fr + Fc + Fa

        # ==============================================================================
        # Return
        # ==============================================================================
        return [Fp, Fr, Fc, Fa, Ft]

    ###################################################################################################################
    # Acceleration
    ###################################################################################################################
    def calc_acc(self, M, v, ang, setup):
        # ==============================================================================
        # Init
        # ==============================================================================
        r = setup['Par']['VEH']['r_dyn']
        m_a = setup['Par']['VEH']['m_a']

        # ==============================================================================
        # Pre-Processing
        # ==============================================================================
        [Fp, Fr, Fc, _, _] = self.calc_Force(v, 0, ang, setup)
        Fd = Fp + Fr + Fc

        # ==============================================================================
        # Calculation
        # ==============================================================================
        Fa = M / r
        a = (Fa - Fd) / (self.m + m_a)

        # ==============================================================================
        # Return
        # ==============================================================================
        return a

#######################################################################################################################
# References
#######################################################################################################################

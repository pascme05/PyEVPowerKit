#######################################################################################################################
#######################################################################################################################
# Title:        Python Electric Vehicle Power Toolkit (PyEVPowerKit)
# Topic:        EV Modeling
# File:         classEMA
# Date:         18.03.2024
# Author:       Dr. Pascal A. Schirmer
# Version:      V.0.1
# Copyright:    Pascal Schirmer
#######################################################################################################################
#######################################################################################################################

#######################################################################################################################
# Function Description
#######################################################################################################################
"""
A short description of the class goes here.
Inputs:     1)
            2)
            N)
Outputs:    1)
            2)
            M)
"""

#######################################################################################################################
# Import libs
#######################################################################################################################
# ==============================================================================
# Internal
# ==============================================================================

# ==============================================================================
# External
# ==============================================================================
import numpy as np
import math as mt


#######################################################################################################################
# Class PSM
#######################################################################################################################
class classPSM:
    ###################################################################################################################
    # Constructor
    ###################################################################################################################
    def __init__(self, p, n_max, n_0, T_max, J_rot, I_max, P_max, Psi, L_d, L_q, L_sig, R_s, c_b, c_w, K_h, K_f, C_th, R_th):
        self.p = p
        self.n_max = n_max
        self.n_0 = n_0
        self.T_max = T_max
        self.J_rot = J_rot
        self.I_max = I_max
        self.P_max = P_max
        self.Psi = Psi
        self.L_d = L_d
        self.L_q = L_q
        self.L_sig = L_sig
        self.R_s = R_s
        self.K_h = K_h
        self.K_f = K_f
        self.c_b = c_b
        self.c_w = c_w
        self.C_th = C_th
        self.R_th = R_th

    ###################################################################################################################
    # Mechanics
    ###################################################################################################################
    def calc_mech(self, M_Gbx, n_Gbx, P_Gbx, eta):
        # ==============================================================================
        # Calculation
        # ==============================================================================
        M_Ema = M_Gbx / eta
        n_Ema = n_Gbx
        P_Ema = P_Gbx

        # ==============================================================================
        # Return
        # ==============================================================================
        return [M_Ema, n_Ema, P_Ema]

    ###################################################################################################################
    # Elec Surface Magnets
    ###################################################################################################################
    def calc_elec_SM(self, n_Ema, M_Ema, Vdc, T):
        # ==============================================================================
        # Init
        # ==============================================================================
        def sat(x, theta):
            return min(theta, max(-theta, x))

        # ==============================================================================
        # Pre-processing
        # ==============================================================================
        Rs = self.R_s * (1 + 0.00393 * (T - 20))
        v_max = Vdc / np.sqrt(3) - Rs * self.I_max
        w_m_base = (1 / self.p) * v_max / (np.sqrt((self.L_q * self.I_max) ** 2 + self.Psi ** 2))
        w_m = 2 * np.pi * n_Ema
        R_Fe = 1 / (self.K_f + self.K_h / (self.p * w_m + 1) + 1e-9)

        # ==============================================================================
        # Calculation
        # ==============================================================================
        if w_m <= w_m_base:
            id_sat = 0
            iq_mtpa = M_Ema / (3 / 2 * self.p * self.Psi)
            iq_sat = sat(iq_mtpa, self.I_max)

        else:
            id_fw = (self.p * w_m_base - w_m * self.p) * self.Psi / (w_m * self.p * self.L_d)
            iq_fw = M_Ema / (3 / 2 * self.p * self.Psi)
            id_sat = sat(id_fw, self.I_max)
            iq_lim = np.sqrt(self.I_max ** 2 - id_sat ** 2)
            iq_sat = sat(iq_fw, iq_lim)

        # ==============================================================================
        # Post-processing
        # ==============================================================================
        # ------------------------------------------
        # Flux Current
        # ------------------------------------------
        id0 = id_sat
        iq0 = iq_sat

        # ------------------------------------------
        # Iron Current
        # ------------------------------------------
        vd0 = - w_m * self.p * self.L_q * iq0
        vq0 = w_m * self.p * self.L_d * id0 + w_m * self.p * self.Psi
        id_fe = vd0 / R_Fe
        iq_fe = vq0 / R_Fe
        id = id0 + id_fe
        iq = iq0 + iq_fe

        # ------------------------------------------
        # Stator Quantities
        # ------------------------------------------
        # Current
        Is = np.sqrt(id ** 2 + iq ** 2)

        # Voltage
        vd = Rs * id - w_m * self.p * self.L_q * iq + (w_m * self.p) ** 2 / R_Fe * (self.L_q * self.L_d * id + self.L_q * self.Psi)
        vq = Rs * iq + w_m * self.p * self.L_d * id + (w_m * self.p) ** 2 / R_Fe * (self.L_q * self.L_d * iq) + w_m * self.p * self.Psi
        Vs = np.sqrt(vd ** 2 + vq ** 2)

        # ==============================================================================
        # Return
        # ==============================================================================
        return [id, iq, Is, vd, vq, Vs]

    ###################################################################################################################
    # Elec Interior Magnets
    ###################################################################################################################
    def calc_elec_IM(self, n_Ema, M_Ema, Vdc, T):
        # ==============================================================================
        # Pre-processing
        # ==============================================================================
        Rs = self.R_s * (1 + 0.00393 * (T - 20))
        v_max = Vdc / np.sqrt(3) - Rs * self.I_max
        w_m_base = 2 * np.pi * self.n_0
        w_m = 2 * np.pi * n_Ema
        R_Fe = 1 / (self.K_f + self.K_h / (self.p * w_m + 1) + 1e-9)

        # ==============================================================================
        # Calculation
        # ==============================================================================
        # ------------------------------------------
        # Magnetizing Current
        # ------------------------------------------
        i_m_ref = M_Ema / (3 / 2 * self.p * self.Psi)
        i_m = min(i_m_ref, self.I_max)
        id_mtpa = self.Psi / (4 * (self.L_q - self.L_d)) - np.sqrt(self.Psi ** 2 / (16 * (self.L_q - self.L_d) ** 2) + i_m ** 2 / 2)
        iq_mtpa = np.sqrt(i_m ** 2 - id_mtpa ** 2)
        id_fw = (-self.Psi * self.L_d + np.sqrt((self.Psi * self.L_d) ** 2 - (self.L_d ** 2 - self.L_q ** 2) * (
                self.Psi ** 2 + self.L_q ** 2 * self.I_max ** 2 - v_max ** 2 / (self.p * w_m) ** 2))) / (self.L_d ** 2 - self.L_q ** 2)

        # ------------------------------------------
        # d/q Currents (stationary)
        # ------------------------------------------
        if w_m <= w_m_base:
            iq_sat = iq_mtpa
            id_sat = id_mtpa

        else:
            id_sat = max(id_fw, -self.I_max)
            iq_fw = np.sqrt(self.I_max ** 2 - id_fw ** 2)
            if iq_fw < i_m:
                iq_sat = iq_fw
            else:
                iq_sat = i_m

        # ==============================================================================
        # Post-processing
        # ==============================================================================
        # ------------------------------------------
        # Flux Current
        # ------------------------------------------
        id0 = id_sat
        iq0 = iq_sat

        # ------------------------------------------
        # Iron Current
        # ------------------------------------------
        vd0 = - w_m * self.p * self.L_q * iq0
        vq0 = w_m * self.p * self.L_d * id0 + w_m * self.p * self.Psi
        id_fe = vd0 / R_Fe
        iq_fe = vq0 / R_Fe
        id = id0 + id_fe
        iq = iq0 + iq_fe

        # ------------------------------------------
        # Stator Quantities
        # ------------------------------------------
        # Current
        Is = np.sqrt(id ** 2 + iq ** 2)

        # Voltage
        vd = Rs * id - w_m * self.p * self.L_q * iq + (w_m * self.p) ** 2 / R_Fe * (self.L_q * self.L_d * id + self.L_q * self.Psi)
        vq = Rs * iq + w_m * self.p * self.L_d * id + (w_m * self.p) ** 2 / R_Fe * (self.L_q * self.L_d * iq) + w_m * self.p * self.Psi
        Vs = np.sqrt(vd ** 2 + vq ** 2)

        # ==============================================================================
        # Return
        # ==============================================================================
        return [id, iq, Is, vd, vq, Vs]

    ###################################################################################################################
    # Electrical
    ###################################################################################################################
    def calc_elec(self, n_Ema, M_Ema, type, Vdc, fs, T):
        # ==============================================================================
        # Pre-processing
        # ==============================================================================
        w_m = 2 * np.pi * n_Ema
        Pout = M_Ema * w_m

        # ==============================================================================
        # Calculation
        # ==============================================================================
        # ------------------------------------------
        # Currents and Voltages
        # ------------------------------------------
        # Interior Magnet
        if type == 2:
            [id, iq, Is, vd, vq, Vs] = self.calc_elec_IM(n_Ema, M_Ema, Vdc, T)

        # Surface Magnet
        else:
            [id, iq, Is, vd, vq, Vs] = self.calc_elec_SM(n_Ema, M_Ema, Vdc, T)

        # ------------------------------------------
        # Flux
        # ------------------------------------------
        lam_d = self.L_d * id + self.Psi
        lam_q = self.L_q * iq
        lam_s = np.sqrt(lam_d ** 2 + lam_q ** 2)

        # ------------------------------------------
        # Losses
        # ------------------------------------------
        [Pv, _, _, _] = self.calc_loss(n_Ema, Is, Vs, Vdc, fs, T)

        # ------------------------------------------
        # Inner Torque
        # ------------------------------------------
        # T_in = 3 / 2 * self.p * (iq * lam_d - id * lam_q)

        # ==============================================================================
        # Post-Processing
        # ==============================================================================
        Pin = Pout + Pv
        eta = Pout / Pin
        phi = mt.acos(Pin / (3 / 2 * Vs * Is + 1e-9))
        PF = np.cos(phi)

        # ==============================================================================
        # Return
        # ==============================================================================
        return [id, iq, Is, vd, vq, Vs, lam_s, Pin, Pout, Pv, eta, PF]

    ###################################################################################################################
    # Losses
    ###################################################################################################################
    def calc_loss(self, n_Ema, Is, Vs, Vdc, fs, T):
        # ==============================================================================
        # Init
        # ==============================================================================
        HDF = 0.4

        # ==============================================================================
        # Pre-processing
        # ==============================================================================
        Rs = self.R_s * (1 + 0.00393 * (T - 20))
        w_m = 2 * np.pi * n_Ema
        R_Fe = 1 / (self.K_f + self.K_h / (self.p * w_m + 1) + 1e-9)

        # ==============================================================================
        # Calculation
        # ==============================================================================
        # ------------------------------------------
        # Mechanical
        # ------------------------------------------
        bear_loss = self.c_b * n_Ema
        wind_loss = self.c_w * n_Ema**2
        mech_loss = bear_loss + wind_loss

        # ------------------------------------------
        # Electrical
        # ------------------------------------------
        # Stator
        stator_ohm_loss = 3 * Rs * Is ** 2
        stator_mag_loss = 3 * (Vs - Rs * Is) ** 2 / R_Fe
        stator_har_loss = 3 * Rs * (Vdc / (24 * self.L_sig * fs)) ** 2 * HDF
        stator_loss = stator_ohm_loss + stator_mag_loss + stator_har_loss

        # Rotor (tbd)
        rotor_ohm_loss = 0
        rotor_mag_loss = 0
        rotor_har_loss = 0
        rotor_loss = rotor_ohm_loss + rotor_mag_loss + rotor_har_loss

        # ==============================================================================
        # Post-Processing
        # ==============================================================================
        Pv = mech_loss + stator_loss + rotor_loss

        # ==============================================================================
        # Return
        # ==============================================================================
        return [Pv, mech_loss, stator_loss, rotor_loss]

    ###################################################################################################################
    # Thermal
    ###################################################################################################################
    def calc_therm(self, dt, Tc, Pv1, Pv2):
        # ==============================================================================
        # Initialisation
        # ==============================================================================
        tau = self.R_th * self.C_th
        Rth = self.R_th

        # ==============================================================================
        # Calculation
        # ==============================================================================
        dT = (2 * tau - dt) / (2 * tau + dt) * Tc + (Rth * dt) / (2 * tau + dt) * (Pv1 + Pv2)

        # ==============================================================================
        # Return
        # ==============================================================================
        return dT

#######################################################################################################################
# References
#######################################################################################################################
